import fg from "fast-glob"
import fs from "node:fs/promises"
import path from "node:path"

const HTTP_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE"]

function APIConstructor(opts = {}) {
    let serverRef

    const extensions = opts.extensions ?? ["ts", "tsx"]
    const baseUrl = (opts.baseUrl ?? "").replace(/\/+$/, "")

    // zod API 파일들이 있는 폴더 (지금은 app/api)
    const srcDir = path.resolve(opts.srcDir ?? "./app/api")

    // 생성된 타입/맵 파일들이 들어갈 위치 (출력 루트)
    const typesRoot = path.resolve(opts.typesRoot ?? "./.api")
    const typesDir = path.join(typesRoot, "types")
    const requestFile = path.join(typesDir, "request.ts")
    const responseFile = path.join(typesDir, "response.ts")
    const endpointFile = path.join(typesDir, "endpoint.ts")

    const lazy = opts.lazy ?? true

    // fast-glob는 상대 패턴이 더 안정적이라 이렇게 분리
    const relSrcDir = path
        .relative(process.cwd(), srcDir)
        .replace(/\\/g, "/")
        .replace(/\/+$/, "")

    const PATTERN = `${relSrcDir}/**/*.{${extensions.join(",")}}`

    function isAPIFile(absFile) {
        const ext = path.extname(absFile).slice(1)
        if (!extensions.includes(ext)) return false

        const rel = path.relative(srcDir, absFile).replace(/\\/g, "/")
        if (rel.startsWith("..")) return false

        return true
    }

    function toAPIPath(absFile) {
        const rel = path.relative(srcDir, absFile).replace(/\\/g, "/")
        const noExt = rel.replace(/\.[^.]+$/, "")
        const segments = noExt.split("/")

        const normalized = segments
            .map((seg, i) => {
                if (seg === "index") {
                    return i === segments.length - 1 ? "" : seg
                }
                return seg.replace(/\$([A-Za-z0-9_]+)/g, ":$1")
            })
            .filter(Boolean)
            .join("/")

        const full = (baseUrl + "/" + normalized).replace(/\/\/+/g, "/")
        return full || "/"
    }

    function generateImportPath(absFile) {
        const root = process.cwd()
        let rel = path.relative(root, absFile)

        const noExt = rel.replace(/\.[^.]+$/, "")

        if (!rel.startsWith(".")) rel = "./" + noExt
        return rel.replace(/\\/g, "/")
    }

    async function ensureTypesDir() {
        await fs.mkdir(typesDir, { recursive: true })
    }

    function detectMethods(code) {
        const methods = []
        for (const m of HTTP_METHODS) {
            if (code.includes(`${m}Request`) || code.includes(`${m}Response`)) {
                methods.push(m)
            }
        }
        return methods
    }

    async function scanAndBuild() {
        // relative 패턴 + absolute 결과
        const files = await fg(PATTERN, { dot: false, absolute: true })
        const APIEntries = []

        files.sort((a, b) => a.length - b.length || a.localeCompare(b))

        for (const abs of files) {
            if (!isAPIFile(abs)) continue

            const code = await fs.readFile(abs, "utf8")
            const methods = detectMethods(code)

            if (methods.length === 0) continue

            const APIPath = toAPIPath(abs)
            const importPath = generateImportPath(abs)

            APIEntries.push({
                path: APIPath,
                importPath,
                methods,
            })
        }

        await ensureTypesDir()
        await buildRequestFile(APIEntries)
        await buildResponseFile(APIEntries)
        await buildEndpointFile(APIEntries)

        return APIEntries
    }

    async function buildRequestFile(entries) {
        const lines = []

        lines.push("// THIS FILE IS AUTO-GENERATED BY vite-plugin-api-constructor.")
        lines.push("// DO NOT EDIT MANUALLY.\n")
        lines.push('import type { z } from "zod";')

        entries.forEach((entry, i) => {
            const varName = `R${i}`
            lines.push(`import * as ${varName} from "${entry.importPath}";`)
        })

        lines.push("")
        lines.push("export const requestMap = {")
        entries.forEach((entry, i) => {
            const varName = `R${i}`
            lines.push(`  "${entry.path}": {`)
            entry.methods.forEach((m) => {
                lines.push(`    ${m}: ${varName}.${m}Request,`)
            })
            lines.push("  },")
        })
        lines.push("} as const;")
        lines.push("")
        lines.push("export type APIPath = keyof typeof requestMap;")
        lines.push("export type RequestMap = {")
        lines.push("  [P in keyof typeof requestMap]: {")
        lines.push(
            "    [M in keyof typeof requestMap[P]]: z.infer<(typeof requestMap)[P][M]>;",
        )
        lines.push("  }")
        lines.push("};")
        lines.push("")
        lines.push(
            "export type RequestOf<P extends APIPath, M extends keyof RequestMap[P]> = RequestMap[P][M];",
        )
        lines.push("")

        await fs.writeFile(requestFile, lines.join("\n"), "utf8")
    }

    async function buildResponseFile(entries) {
        const lines = []

        lines.push("// THIS FILE IS AUTO-GENERATED BY vite-plugin-api-constructor.")
        lines.push("// DO NOT EDIT MANUALLY.\n")
        lines.push('import type { z } from "zod";')

        entries.forEach((entry, i) => {
            const varName = `R${i}`
            lines.push(`import * as ${varName} from "${entry.importPath}";`)
        })

        lines.push("")
        lines.push("export const responseMap = {")
        entries.forEach((entry, i) => {
            const varName = `R${i}`
            lines.push(`  "${entry.path}": {`)
            entry.methods.forEach((m) => {
                lines.push(`    ${m}: ${varName}.${m}Response,`)
            })
            lines.push("  },")
        })
        lines.push("} as const;")
        lines.push("")
        lines.push("export type APIPath = keyof typeof responseMap;")
        lines.push("export type ResponseMap = {")
        lines.push("  [P in keyof typeof responseMap]: {")
        lines.push(
            "    [M in keyof typeof responseMap[P]]: z.infer<(typeof responseMap)[P][M]>;",
        )
        lines.push("  }")
        lines.push("};")
        lines.push("")
        lines.push(
            "export type ResponseOf<P extends APIPath, M extends keyof ResponseMap[P]> = ResponseMap[P][M];",
        )
        lines.push("")

        await fs.writeFile(responseFile, lines.join("\n"), "utf8")
    }

    async function buildEndpointFile(entries) {
        const lines = []

        lines.push("// THIS FILE IS AUTO-GENERATED BY vite-plugin-api-constructor.")
        lines.push("// DO NOT EDIT MANUALLY.\n")

        lines.push("export const APIEndPoints = {")
        entries.forEach((entry) => {
            const methodsArray = entry.methods.map((m) => `"${m}"`).join(", ")
            lines.push(`  "${entry.path}": [${methodsArray}],`)
        })
        lines.push("} as const;")
        lines.push("")
        lines.push("export type APIEndPoint = keyof typeof APIEndPoints;")
        lines.push(
            "export type APIMethodOf<P extends APIEndPoint> = (typeof APIEndPoints)[P][number];",
        )
        lines.push("")

        await fs.writeFile(endpointFile, lines.join("\n"), "utf8")
    }

    // --- 파일 변경 감지 & 디바운스 ---

    let timer = null
    function debouncedRebuild() {
        if (timer) clearTimeout(timer)
        timer = setTimeout(async () => {
            try {
                await scanAndBuild()
                if (serverRef?.ws) {
                    serverRef.ws.send({ type: "full-reload" })
                }
            } catch (err) {
                console.error("[api-constructor] rebuild error:", err)
            }
        }, 80)
    }

    return {
        name: "vite-plugin-api-constructor",
        enforce: "pre",

        async buildStart() {
            await scanAndBuild()
        },

        configureServer(server) {
            serverRef = server

            server.watcher.add(srcDir)

            const handler = (p) => {
                const abs = path.resolve(p)
                if (!abs.startsWith(srcDir)) return
                if (!isAPIFile(abs)) return
                debouncedRebuild()
            }

            server.watcher.on("add", handler)
            server.watcher.on("change", handler)
            server.watcher.on("unlink", handler)
        },

        resolveId(id) {
            return null
        },

        load(id) {
            return null
        },
    }
}

export { APIConstructor }
