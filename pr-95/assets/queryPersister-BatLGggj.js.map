{"version":3,"mappings":"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","names":["MIXPANEL_TOKEN","clientEnv","isInitialized","mixpanelInstance","getMixpanel","__vitePreload","initMixpanel","mixpanel","identifyUser","user","resetUser","trackEvent","eventName","properties","promisifyRequest","request","resolve","reject","createStore","dbName","storeName","dbp","getDB","db","txMode","callback","defaultGetStoreFunc","defaultGetStore","get","key","customStore","store","set","value","del","IDB_KEY","serialize","client","deserialize","cachedString","createIDBPersister","serialized","cached","idbPersister","clearQueryCache"],"ignoreList":[1],"sources":["../../../app/libs/mixpanel/index.ts","../../../node_modules/.pnpm/idb-keyval@6.2.2/node_modules/idb-keyval/dist/index.js","../../../app/libs/offline/queryPersister.ts"],"sourcesContent":["import { clientEnv } from \"@/env\"\n\nexport const MIXPANEL_TOKEN = clientEnv.VITE_MIXPANEL_TOKEN\n\nlet isInitialized = false\nlet mixpanelInstance: typeof import(\"mixpanel-browser\").default | null = null\n\nconst getMixpanel = async () => {\n    if (typeof window === \"undefined\") return null\n    if (!mixpanelInstance) {\n        const module = await import(\"mixpanel-browser\")\n        mixpanelInstance = module.default\n    }\n    return mixpanelInstance\n}\n\nexport const initMixpanel = async () => {\n    if (typeof window === \"undefined\") return\n    if (!MIXPANEL_TOKEN || isInitialized) return\n\n    const mixpanel = await getMixpanel()\n    if (!mixpanel) return\n\n    mixpanel.init(MIXPANEL_TOKEN, {\n        debug: process.env.NODE_ENV === \"development\",\n        track_pageview: true,\n        persistence: \"localStorage\",\n        autocapture: true,\n        record_sessions_percent: 100,\n    })\n    isInitialized = true\n}\n\nexport const identifyUser = async (user: {\n    id: number\n    email: string\n    name?: string\n    studentNumber?: number\n    degree?: string\n}) => {\n    if (typeof window === \"undefined\") return\n    if (!MIXPANEL_TOKEN || !isInitialized) return\n\n    const mixpanel = await getMixpanel()\n    if (!mixpanel) return\n\n    mixpanel.identify(user.id.toString())\n    mixpanel.people.set({\n        $email: user.email,\n        $name: user.name,\n        student_number: user.studentNumber,\n        degree: user.degree,\n    })\n}\n\nexport const resetUser = async () => {\n    if (typeof window === \"undefined\") return\n    if (!MIXPANEL_TOKEN || !isInitialized) return\n\n    const mixpanel = await getMixpanel()\n    if (!mixpanel) return\n\n    mixpanel.reset()\n}\n\nexport const trackEvent = async (\n    eventName: string,\n    properties?: Record<string, unknown>,\n) => {\n    if (typeof window === \"undefined\") return\n    if (!MIXPANEL_TOKEN || !isInitialized) return\n\n    const mixpanel = await getMixpanel()\n    if (!mixpanel) return\n\n    mixpanel.track(eventName, properties)\n}\n","function promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        // @ts-ignore - file size hacks\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        // @ts-ignore - file size hacks\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\nfunction createStore(dbName, storeName) {\n    let dbp;\n    const getDB = () => {\n        if (dbp)\n            return dbp;\n        const request = indexedDB.open(dbName);\n        request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n        dbp = promisifyRequest(request);\n        dbp.then((db) => {\n            // It seems like Safari sometimes likes to just close the connection.\n            // It's supposed to fire this event when that happens. Let's hope it does!\n            db.onclose = () => (dbp = undefined);\n        }, () => { });\n        return dbp;\n    };\n    return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));\n}\nlet defaultGetStoreFunc;\nfunction defaultGetStore() {\n    if (!defaultGetStoreFunc) {\n        defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction get(key, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction set(key, value, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic â€“ if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction setMany(entries, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction getMany(keys, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction update(key, updater, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => \n    // Need to create the promise manually.\n    // If I try to chain promises, the transaction closes in browsers\n    // that use a promise polyfill (IE10/11).\n    new Promise((resolve, reject) => {\n        store.get(key).onsuccess = function () {\n            try {\n                store.put(updater(this.result), key);\n                resolve(promisifyRequest(store.transaction));\n            }\n            catch (err) {\n                reject(err);\n            }\n        };\n    }));\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction del(key, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction delMany(keys, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        keys.forEach((key) => store.delete(key));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction clear(customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\nfunction eachCursor(store, callback) {\n    store.openCursor().onsuccess = function () {\n        if (!this.result)\n            return;\n        callback(this.result);\n        this.result.continue();\n    };\n    return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction keys(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAllKeys) {\n            return promisifyRequest(store.getAllKeys());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);\n    });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction values(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAll) {\n            return promisifyRequest(store.getAll());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);\n    });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction entries(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        // (although, hopefully we'll get a simpler path some day)\n        if (store.getAll && store.getAllKeys) {\n            return Promise.all([\n                promisifyRequest(store.getAllKeys()),\n                promisifyRequest(store.getAll()),\n            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));\n        }\n        const items = [];\n        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));\n    });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n","import type { PersistedClient, Persister } from \"@tanstack/react-query-persist-client\"\nimport { del, get, set } from \"idb-keyval\"\n\nconst IDB_KEY = \"otlplus-query-cache\"\n\nfunction serialize(client: PersistedClient): string {\n    return JSON.stringify(client)\n}\n\nfunction deserialize(cachedString: string): PersistedClient {\n    return JSON.parse(cachedString) as PersistedClient\n}\n\nexport function createIDBPersister(): Persister {\n    return {\n        persistClient: async (client: PersistedClient) => {\n            const serialized = serialize(client)\n            await set(IDB_KEY, serialized)\n        },\n        restoreClient: async () => {\n            const cached = await get<string>(IDB_KEY)\n            if (!cached) return undefined\n            return deserialize(cached)\n        },\n        removeClient: async () => {\n            await del(IDB_KEY)\n        },\n    }\n}\n\nexport const idbPersister = createIDBPersister()\n\nexport async function clearQueryCache(): Promise<void> {\n    await idbPersister.removeClient()\n}\n"],"file":"queryPersister-BatLGggj.js"}